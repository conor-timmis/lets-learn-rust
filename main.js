// main.js: The central script for loading the WASM module and handling page interactions.

// Import the initializer function (`init`) and the specific Rust functions we want to use
// from the JavaScript glue code generated by wasm-pack.
import init, { greet, add_numbers_and_explain, reverse_string, calculate_stats } from './rust_lib/pkg/rust_lib.js';

// --- Rust Code Snippets (for display) ---
const greetCode = `
#[wasm_bindgen]
pub fn greet(name: &str) -> String {
    format!("Hello from Rust, {}! I am learning too!", name)
}`.trim();

const addNumbersCode = `
#[wasm_bindgen]
pub fn add_numbers_and_explain(num1: i32, num2: i32) -> String {
    let sum = num1 + num2;
    format!("Rust says: {} + {} = {}. Perfect!", num1, num2, sum)
}`.trim();

const reverseStringCode = `
#[wasm_bindgen]
pub fn reverse_string(text: &str) -> String {
    text.chars().rev().collect::<String>()
}`.trim();

const calculateStatsCode = `
#[wasm_bindgen]
pub fn calculate_stats(numbers_str: &str) -> String {
    if numbers_str.trim().is_empty() {
        return String::from("Input is empty. Please provide some numbers.");
    }
    let mut numbers: Vec<i32> = Vec::new();
    let parts = numbers_str.split(',');
    for part in parts {
        match part.trim().parse::<i32>() {
            Ok(num) => numbers.push(num),
            Err(_) => return format!("Error: Could not parse '{}' as a number. Please use comma-separated integers.", part.trim()),
        }
    }
    if numbers.is_empty() {
        return String::from("No valid numbers found to calculate statistics.");
    }
    let count = numbers.len();
    let sum: i32 = numbers.iter().sum();
    let average = sum as f64 / count as f64;
    let min_val = *numbers.iter().min().unwrap(); 
    let max_val = *numbers.iter().max().unwrap();
    format!(
        "Statistics Results:\nCount: {}\nSum: {}\nAverage: {:.2}\nMinimum: {}\nMaximum: {}",
        count, sum, average, min_val, max_val
    )
}`.trim();

// The main asynchronous function to load WASM and set up the application.
async function runWasm() {
    try {
        await init();

        // --- Pagination Variables and Elements ---
        // Keep track of the currently displayed page.
        let currentPage = 1;
        // Get all elements that represent a page (e.g., <div class="page">).
        const pages = document.querySelectorAll('.page');
        // Get the previous and next buttons (we have them at the top and bottom).
        const prevButton = document.querySelectorAll('#prev-page');
        const nextButton = document.querySelectorAll('#next-page');
        // Calculate the total number of pages based on the number of page elements.
        const totalPages = pages.length;

        // --- Helper function to get an element by ID and log if not found ---
        // Useful for preventing errors if an expected element is missing.
        function getElement(id) {
            const element = document.getElementById(id);
            if (!element) {
                console.error(`Error: Required HTML element with id '${id}' not found.`);
            }
            return element;
        }

        // --- Helper function to show a specific page and hide all others ---
        function showPage(pageNumber) {
            // Hide all elements with the class 'page'.
            pages.forEach(page => {
                page.style.display = 'none';
            });

            // Get the specific page element to show based on its ID (e.g., 'page1', 'page2').
            const pageToShow = getElement(`page${pageNumber}`);
            // If the page element is found, display it as a block.
            if (pageToShow) {
                pageToShow.style.display = 'block';
            }
            // Note: If a page element is not found, the getElement helper will log an error.
        }

         // --- Helper function to update the disabled state of pagination buttons ---
         function updateButtonStates() {
            // Disable the previous button if on the first page, otherwise enable it.
            prevButton.forEach(button => button.disabled = currentPage === 1);
            // Disable the next button if on the last page, otherwise enable it.
            nextButton.forEach(button => button.disabled = currentPage === totalPages);
        }

        // --- Helper function to inject code snippets into the display elements ---
        function injectCodeSnippet(elementId, code) {
            const element = getElement(elementId);
            // If the display element is found, set its text content to the provided code string.
            if (element) {
              element.textContent = code;
            }
        }

        // --- Event listeners for pagination buttons ---
        // Add click listeners to all 'Previous' buttons.
        prevButton.forEach(button => button.addEventListener('click', () => {
            // If not on the first page, decrease the page number.
            if (currentPage > 1) {
                currentPage--;
                // Show the new page and update button states.
                showPage(currentPage);
                updateButtonStates();
            }
        }));

        // Add click listeners to all 'Next' buttons.
        nextButton.forEach(button => button.addEventListener('click', () => {
            // If not on the last page, increase the page number.
            if (currentPage < totalPages) {
                currentPage++;
                // Show the new page and update button states.
                showPage(currentPage);
                updateButtonStates();
            }
        }));
        
        // --- Get References to HTML Elements for Each Example ---
        // Greet Example elements (from page 1)
        const nameInput = getElement('name-input');
        const greetButton = getElement('greet-button');
        const rustAppContainer = getElement('rust-app-container');
        const greetCodeDisplay = getElement('greet-code-display');

        // Number Adder Example elements (from page 1)
        const num1Input = getElement('num1-input');
        const num2Input = getElement('num2-input');
        const addNumbersButton = getElement('add-numbers-button');
        const adderResultContainer = getElement('adder-result-container');
        const adderCodeDisplay = getElement('adder-code-display');

        // String Reverser Example elements (from page 1, now moved to page 2 in HTML structure)
        const stringInput = getElement('string-input');
        const reverseButton = getElement('reverse-button');
        const reverserResultContainer = getElement('reverser-result-container');
        const reverserCodeDisplay = getElement('reverser-code-display');

         // Stats Calculator Example elements (from page 1, now moved to page 2 in HTML structure)
         const statsInput = getElement('stats-input');
         const calculateStatsButton = getElement('calculate-stats-button');
         // Note: statsResultContainer targets the div, we'll specifically target the <pre> inside for output
         const statsResultContainer = getElement('stats-result-container');
         const statsResultPre = statsResultContainer ? statsResultContainer.querySelector('pre') : null;
         const statsCodeDisplay = getElement('stats-code-display');

        // --- Populate Code Displays with Rust Snippets ---
        injectCodeSnippet('greet-code-display', greetCode);
        injectCodeSnippet('adder-code-display', addNumbersCode);
        injectCodeSnippet('reverser-code-display', reverseStringCode);
        injectCodeSnippet('stats-code-display', calculateStatsCode);

        // --- Logic for Each Interactive Example ---

        // Greet Example Logic: Event listener and initial display.
        function updateGreeting(name) { rustAppContainer.textContent = greet(name); }
        // Check if elements exist (important with pagination where elements might not be on the current page).
        if (nameInput && rustAppContainer && greetButton) {
            updateGreeting(nameInput.value); // Show initial greeting on load.
            // Add event listener only if the button element exists.
            greetButton.addEventListener('click', () => {
                const userName = nameInput.value.trim();
                if (userName) { updateGreeting(userName); } 
                else { rustAppContainer.textContent = "Please enter a name first!"; }
            });
        }

        // Number Adder Example Logic: Event listener and initial display.
        function updateAdderResult(val1, val2) {
            const num1 = parseInt(val1, 10); const num2 = parseInt(val2, 10);
            if (isNaN(num1) || isNaN(num2)) { adderResultContainer.textContent = "Please enter valid numbers."; return; }
            adderResultContainer.textContent = add_numbers_and_explain(num1, num2);
        }
         // Check if elements exist.
        if (num1Input && num2Input && adderResultContainer && addNumbersButton) {
             updateAdderResult(num1Input.value, num2Input.value);
             addNumbersButton.addEventListener('click', () => {
                 updateAdderResult(num1Input.value, num2Input.value);
             });
         }

        // String Reverser Example Logic: Event listener and initial display.
        function updateReversedString(text) { reverserResultContainer.textContent = reverse_string(text); }
         // Check if elements exist.
        if (stringInput && reverserResultContainer && reverseButton) {
            updateReversedString(stringInput.value); // Initial reverse.
            reverseButton.addEventListener('click', () => {
                const textToReverse = stringInput.value;
                // No specific validation needed for empty string, reverse_string handles it.
                updateReversedString(textToReverse);
            });
        }

         // Stats Calculator Example Logic: Event listener and initial display.
         function performStatisticsCalculation() {
             const numbersStr = statsInput.value;
             // Update the text content of the <pre> tag within the container.
             if (statsResultPre) {
                statsResultPre.textContent = calculate_stats(numbersStr);
             }
         }
         // Check if elements exist.
         if (statsInput && statsResultContainer && calculateStatsButton && statsResultPre) {
             performStatisticsCalculation(); // Initial calculation.
             calculateStatsButton.addEventListener('click', performStatisticsCalculation);
         }


        // --- Initial Setup for Pagination ---
        // Show the first page on load.
        showPage(currentPage);
        // Update the initial state of the pagination buttons.
        updateButtonStates();

    } catch (error) {
        // --- Error Handling for WASM Loading or Initialization ---
        console.error("WASM Error during initialization or execution:", error);
        // Try to find a container to display a user-friendly error message.
        // Check multiple possible result containers for the error message display.
        const errorDisplayContainer = getElement('rust-app-container') || 
                                    getElement('adder-result-container') || 
                                    getElement('reverser-result-container') ||
                                    (getElement('stats-result-container') ? getElement('stats-result-container').querySelector('pre') : null);

        if (errorDisplayContainer) {
            errorDisplayContainer.textContent = "Failed to load Rust application. Please check the browser console for details.";
        } else {
            // Fallback if no container found, just log to console.
            console.error("Could not find a container to display the WASM loading error.");
        }
    }
}

// Run the main WASM interaction function when the script is loaded.
runWasm();
